using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using loki_geo;

#nullable enable
namespace CVWTerrain
{
    /// <summary>
    /// This class handles the building and rebuilding of terrain meshes as required by TerrainBuilder objects. Does nothing on its own (and may cause issues if you try!)
    /// </summary>
    [System.Serializable]
    public class TerrainSubmesh
    {
        /// <summary>
        /// This mesh has not previously been built
        /// </summary>
        public bool Built { get; private set; } = false;

        [Tooltip("The Southwest corner of the source texture files. X is Longitude (-W/+E), Y is Latitude (-S/+N)")]
        public Vector2 LowerLeftCorner;
        [Tooltip("The Northeast corner of the source texture files. X is Longitude (-W/+E), Y is Latitude (-S/+N)")]
        public Vector2 UpperRightCorner;

        /// <summary>
        /// The offset, in meters, of this mesh relative to the center of the TerrainBuilder "map" it's generated by.
        /// </summary>
        public Vector64 Offset;
        /// <summary>
        /// The size, in meters, of this submesh.
        /// </summary>
        public Vector64 Size;
        /// <summary>
        /// The actual, WGS-coordinate position that is considered the "center" of this submesh.
        /// </summary>
        public Vector64 worldCenter { get; private set; }

        private TangentMatrix? MapMatrix;
        internal TangentMatrix? PreviewMatrix;

        protected virtual string NamePrefix => "Land";

        /// <summary>
        /// The mesh generated during Build(...), can be accessed for assignment to a MeshFilter.
        /// </summary>
        public Mesh? Mesh { get; private set; }
        private int LastBuildResolution = -1;

        /// <summary>
        /// Initializes this TerrainSubmesh with required parameters. Skipping this will lead to a failed or otherwise erroneous mesh when calling Build(...).
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="size"></param>
        /// <param name="MapMatrix"></param>
        public void Init(Vector64 offset, Vector64 size, TangentMatrix MapMatrix)
        {
            this.Offset = offset;
            this.Size = size;
            this.MapMatrix = MapMatrix;

            Vector64 rawCenter = Offset + (Size / 2);
            worldCenter = MapMatrix.PointToWorldSpace(rawCenter.normalized * Globe.EarthRadius);
        }

        private async Task BuildAsync(Heightmap map, int resolution)
        {
            await Task.Run(() => { Build(map, resolution); });
        }

        /// <summary>
        /// Builds the mesh based on parameters passed by calling Init(...). May behave unexpectedly if you don't call Init(...)!
        /// If the resolution has not changed since the previous call to Build(), this method will return early to avoid doing unnecessary work.
        /// </summary>
        /// <param name="map"></param>
        /// <param name="resolution"></param>
        public void Build(Heightmap map, int resolution)
        {
            if (MapMatrix is null)
                throw new NullReferenceException("Cannot build submesh - MapMatrix was not assigned! Be sure to call Init(...) when creating TerrainSubmesh objects.");
            if (resolution == LastBuildResolution)
            {
                //Debug.Log("Skipping mesh rebuild - same resolution already present.");
                return;
            }

            //Debug.Log($"Rebuilding at resolution {resolution}");
            LastBuildResolution = Mathf.Max(resolution, 1);

            if (Mesh == null) Mesh = new Mesh();
            else Mesh.Clear();

            Mesh.name = $"{NamePrefix}_{Offset}";

            int trueRez = (resolution + 1);

            Vector3[] vertices = new Vector3[trueRez * trueRez];
            int[] triangles = new int[resolution * resolution * 6];

            //Debug.Log($"Total Vertices: {vertices.Length}");

            int StepX = (int)Size.y / resolution;
            int StepZ = (int)Size.z / resolution;

            int tIndex = 0;

            for (int z = 0; z < trueRez; z++)
                for (int x = 0; x < trueRez; x++)
                {
                    int i = x + z * trueRez;

                    Vector64 raw = Offset + new Vector64(0, x * StepX, z * StepZ);
                    Vector64 World = MapMatrix.PointToWorldSpace(raw.normalized * Globe.EarthRadius);
                    LatLonCoord LatLon = Globe.XYZToLL(World, radius: Globe.EarthRadius);

                    float altitude = GetAltitudeAtPoint(map, LatLon);

                    Vector64 altitudeCorrected = World.normalized * (Globe.EarthRadius + altitude);

                    Vector3 localPoint = (altitudeCorrected - worldCenter).ToVector3();

                    vertices[i] = localPoint;

                    if (x == resolution || z == resolution) continue; // Skip triangle generation for this point

                    triangles[tIndex + 0] = i;
                    triangles[tIndex + 1] = i + trueRez + 1;
                    triangles[tIndex + 2] = i + trueRez;

                    triangles[tIndex + 3] = i;
                    triangles[tIndex + 4] = i + 1;
                    triangles[tIndex + 5] = i + trueRez + 1;
                    tIndex += 6;
                }

            Mesh.SetVertices(vertices);
            Mesh.RecalculateBounds();
            Mesh.SetTriangles(triangles, 0);
            Mesh.RecalculateNormals();
            Mesh.Optimize();
            Mesh.UploadMeshData(false);

            //Mesh = m;
            Built = true;
        }

        /// <summary>
        /// Gets an altitude value at a point specified by a LatLonCoord from the passed Heightmap object. Can be overridden like in the case of OceanSubmesh, which needs all altitudes to be zero.
        /// </summary>
        /// <param name="map"></param>
        /// <param name="point"></param>
        /// <returns></returns>
        protected virtual float GetAltitudeAtPoint (Heightmap map, LatLonCoord point) => map.GetValue((float)point.Lat_Degrees, (float)point.Lon_Degrees, false);

        public void OnDrawGizmosSelected()
        {
            if (PreviewMatrix == null) return;

            Gizmos.color = Built ? new Color(LastBuildResolution / 256f, 1, LastBuildResolution / 256f, 1) : Color.red;

            Vector3 LL3 = PreviewMatrix.PointToWorldSpace(Offset.normalized * Globe.EarthRadius).ToVector3();
            Vector3 LR3 = PreviewMatrix.PointToWorldSpace((Offset + new Vector64(0, Size.y, 0)).normalized * Globe.EarthRadius).ToVector3();
            Vector3 UR3 = PreviewMatrix.PointToWorldSpace((Offset + Size).normalized * Globe.EarthRadius).ToVector3();
            Vector3 UL3 = PreviewMatrix.PointToWorldSpace((Offset + new Vector64(0, 0, Size.z)).normalized * Globe.EarthRadius).ToVector3();

            Gizmos.DrawLine(LL3, LR3);
            Gizmos.DrawLine(LR3, UR3);
            Gizmos.DrawLine(UR3, UL3);
            Gizmos.DrawLine(UL3, LL3);
        }
    }
}
